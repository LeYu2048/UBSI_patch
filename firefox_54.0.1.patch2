--- firefox-54.0.1/xpcom/io/nsStreamUtils.cpp	2017-06-15 16:52:36.000000000 -0400
+++ firefox-54.0.1_backup/xpcom/io/nsStreamUtils.cpp	2018-02-23 20:05:17.594051935 -0500
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "../../UBSI.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/Attributes.h"
 #include "nsStreamUtils.h"
@@ -820,6 +821,8 @@
                        uint32_t* aCountWritten)
 {
   char* toBuf = static_cast<char*>(aClosure);
+  UBSI_MEM_READ(aBuffer);
+  UBSI_MEM_WRITE(&toBuf[aOffset]);
   memcpy(&toBuf[aOffset], aBuffer, aCount);
   *aCountWritten = aCount;
   return NS_OK;
--- firefox-54.0.1/layout/base/nsPresContext.cpp	2017-06-15 16:52:30.000000000 -0400
+++ firefox-54.0.1_backup/layout/base/nsPresContext.cpp	2018-03-01 00:29:33.410051935 -0500
@@ -5,6 +5,7 @@
 
 /* a presentation of a document, part 1 */
 
+#include "../../../UBSI.h"
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/EventDispatcher.h"
@@ -310,6 +311,7 @@
     mNeverAnimate = false;
   }
   NS_ASSERTION(mDocument, "Null document");
+		UBSI_MEM_WRITE((void*)this);
 
   // if text perf logging enabled, init stats struct
   if (MOZ_LOG_TEST(gfxPlatform::GetLog(eGfxLog_textperf), LogLevel::Warning)) {
--- firefox-54.0.1/js/src/jsstr.h	2017-06-15 16:52:06.000000000 -0400
+++ firefox-54.0.1_backup/js/src/jsstr.h	2018-02-23 20:50:50.454051935 -0500
@@ -7,6 +7,7 @@
 #ifndef jsstr_h
 #define jsstr_h
 
+#include "../../../UBSI.h"
 #include "mozilla/HashFunctions.h"
 #include "mozilla/PodOperations.h"
 
@@ -110,6 +111,8 @@
 static MOZ_ALWAYS_INLINE void
 js_strncpy(char16_t* dst, const char16_t* src, size_t nelem)
 {
+    UBSI_MEM_READ((void*)src);
+    UBSI_MEM_WRITE((void*)dst);
     return mozilla::PodCopy(dst, src, nelem);
 }
 
@@ -290,6 +293,8 @@
 inline void
 CopyAndInflateChars(char16_t* dst, const char* src, size_t srclen)
 {
+    UBSI_MEM_READ((void*)src);
+    UBSI_MEM_WRITE((void*)dst);
     for (size_t i = 0; i < srclen; i++)
         dst[i] = (unsigned char) src[i];
 }
@@ -297,6 +302,8 @@
 inline void
 CopyAndInflateChars(char16_t* dst, const JS::Latin1Char* src, size_t srclen)
 {
+    UBSI_MEM_READ((void*)src);
+    UBSI_MEM_WRITE((void*)dst);
     for (size_t i = 0; i < srclen; i++)
         dst[i] = src[i];
 }
--- firefox-54.0.1/js/src/builtin/TypedObject.cpp	2017-06-15 16:51:58.000000000 -0400
+++ firefox-54.0.1_backup/js/src/builtin/TypedObject.cpp	2018-02-24 17:35:54.434051935 -0500
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "../../../UBSI.h"
 #include "builtin/TypedObject.h"
 
 #include "mozilla/Casting.h"
@@ -2110,6 +2111,11 @@
     if (!res)
         return nullptr;
 
+				void *UBSI_src = templateObject->inlineTypedMem();
+				void *UBSI_dest = res->inlineTypedMem();
+    UBSI_MEM_READ((void*)UBSI_src);
+    UBSI_MEM_WRITE((void*)UBSI_dest);
+
     memcpy(res->inlineTypedMem(), templateObject->inlineTypedMem(), templateObject->size());
     return res;
 }
--- firefox-54.0.1/js/src/builtin/Intl.cpp	2017-06-15 16:51:58.000000000 -0400
+++ firefox-54.0.1_backup/js/src/builtin/Intl.cpp	2018-02-23 21:20:49.718051935 -0500
@@ -10,6 +10,7 @@
  */
 
 #include "builtin/Intl.h"
+#include "../../../../UBSI.h"
 
 #include "mozilla/Casting.h"
 #include "mozilla/PodOperations.h"
@@ -980,6 +981,8 @@
     }
 
     MOZ_ASSERT(size >= 0);
+    UBSI_MEM_READ((void*)chars.begin());
+    UBSI_MEM_WRITE((void*)cx);
     return NewStringCopyN<CanGC>(cx, chars.begin(), size_t(size));
 }
 
--- firefox-54.0.1/js/src/jsutil.h	2017-06-15 16:52:06.000000000 -0400
+++ firefox-54.0.1_backup/js/src/jsutil.h	2018-02-23 20:05:17.590051935 -0500
@@ -11,6 +11,7 @@
 #ifndef jsutil_h
 #define jsutil_h
 
+#include "../../../UBSI.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/Compiler.h"
 #include "mozilla/GuardObjects.h"
@@ -37,6 +38,8 @@
 static MOZ_ALWAYS_INLINE void*
 js_memcpy(void* dst_, const void* src_, size_t len)
 {
+    UBSI_MEM_READ((void*)src_);
+    UBSI_MEM_WRITE((void*)dst_);
     char* dst = (char*) dst_;
     const char* src = (const char*) src_;
     MOZ_ASSERT_IF(dst >= src, (size_t) (dst - src) >= len);
--- firefox-54.0.1/js/src/jsscript.cpp	2017-06-15 16:52:06.000000000 -0400
+++ firefox-54.0.1_backup/js/src/jsscript.cpp	2018-02-24 16:48:16.726051935 -0500
@@ -8,6 +8,7 @@
  * JS script operations.
  */
 
+#include "../../../UBSI.h"
 #include "jsscriptinlines.h"
 
 #include "mozilla/DebugOnly.h"
@@ -3286,6 +3287,8 @@
         return false;
     }
 
+    UBSI_MEM_READ((void*)src->data);
+    UBSI_MEM_WRITE((void*)dst->data);
     /* NB: Keep this in sync with XDRScript. */
 
     /* Some embeddings are not careful to use ExposeObjectToActiveJS as needed. */
--- firefox-54.0.1/mfbt/PodOperations.h	2017-06-15 16:52:21.000000000 -0400
+++ firefox-54.0.1_backup/mfbt/PodOperations.h	2018-02-23 21:50:18.146051935 -0500
@@ -15,6 +15,7 @@
 #ifndef mozilla_PodOperations_h
 #define mozilla_PodOperations_h
 
+#include "../../../../UBSI.h"
 #include "mozilla/Array.h"
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/Attributes.h"
@@ -98,6 +99,9 @@
 {
   MOZ_ASSERT(aDst + aNElem <= aSrc || aSrc + aNElem <= aDst,
              "destination and source must not overlap");
+
+  UBSI_MEM_READ((void*)aSrc);
+  UBSI_MEM_WRITE((void*)aDst);
   if (aNElem < 128) {
     /*
      * Avoid using operator= in this loop, as it may have been
@@ -118,6 +122,8 @@
   MOZ_ASSERT(aDst + aNElem <= aSrc || aSrc + aNElem <= aDst,
              "destination and source must not overlap");
 
+  UBSI_MEM_READ((void*)aSrc);
+  UBSI_MEM_WRITE((void*)aDst);
   /*
    * Volatile |aDst| requires extra work, because it's undefined behavior to
    * modify volatile objects using the mem* functions.  Just write out the
@@ -154,6 +160,9 @@
 {
   MOZ_ASSERT(aNElem <= SIZE_MAX / sizeof(T),
              "trying to move an impossible number of elements");
+
+  UBSI_MEM_READ((void*)aSrc);
+  UBSI_MEM_WRITE((void*)aDst);
   memmove(aDst, aSrc, aNElem * sizeof(T));
 }
 
--- firefox-54.0.1/dom/workers/WorkerScope.cpp	2017-06-15 16:52:30.000000000 -0400
+++ firefox-54.0.1_backup/dom/workers/WorkerScope.cpp	2018-02-28 16:39:47.722051935 -0500
@@ -6,6 +6,7 @@
 
 #include "WorkerScope.h"
 
+#include "../../../UBSI.h"
 #include "jsapi.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/dom/BindingDeclarations.h"
@@ -708,6 +709,7 @@
     return;
   }
 
+		UBSI_MEM_WRITE((void*)this);
   if (mWorkerPrivate->WorkerScriptExecutedSuccessfully()) {
     RefPtr<Runnable> r = new ReportFetchListenerWarningRunnable(mScope);
     mWorkerPrivate->DispatchToMainThread(r.forget());
--- firefox-54.0.1/dom/events/Event.cpp	2017-06-15 16:52:17.000000000 -0400
+++ firefox-54.0.1_backup/dom/events/Event.cpp	2018-03-01 00:33:50.578051935 -0500
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "../../../UBSI.h"
 #include "AccessCheck.h"
 #include "base/basictypes.h"
 #include "ipc/IPCMessageUtils.h"
@@ -46,11 +47,14 @@
              nsPresContext* aPresContext,
              WidgetEvent* aEvent)
 {
+		UBSI_MEM_WRITE((void*)this);
+		UBSI_MEM_WRITE((void*)aEvent);
   ConstructorInit(aOwner, aPresContext, aEvent);
 }
 
 Event::Event(nsPIDOMWindowInner* aParent)
 {
+		UBSI_MEM_WRITE((void*)this);
   ConstructorInit(nsGlobalWindow::Cast(aParent), nullptr, nullptr);
 }
 
@@ -366,6 +370,7 @@
     return workers::IsCurrentThreadRunningChromeWorker();
   }
   bool trusted = false;
+		UBSI_MEM_WRITE((void*)this);
   nsCOMPtr<nsPIDOMWindowInner> w = do_QueryInterface(aGlobal);
   if (w) {
     nsCOMPtr<nsIDocument> d = w->GetExtantDoc();
@@ -398,6 +403,8 @@
                    const EventInit& aParam)
 {
   RefPtr<Event> e = new Event(aEventTarget, nullptr, nullptr);
+		UBSI_MEM_WRITE((void*)e);
+		UBSI_MEM_WRITE((void*)aEventTarget);
   bool trusted = e->Init(aEventTarget);
   e->InitEvent(aType, aParam.mBubbles, aParam.mCancelable);
   e->SetTrusted(trusted);
@@ -597,6 +604,8 @@
 {
   // Make sure this event isn't already being dispatched.
   NS_ENSURE_TRUE_VOID(!mEvent->mFlags.mIsBeingDispatched);
+		UBSI_MEM_WRITE((void*)this);
+		UBSI_MEM_WRITE((void*)mEvent);
 
   if (IsTrusted()) {
     // Ensure the caller is permitted to dispatch trusted DOM events.
--- firefox-54.0.1/dom/events/DOMEventTargetHelper.cpp	2017-06-15 16:52:17.000000000 -0400
+++ firefox-54.0.1_backup/dom/events/DOMEventTargetHelper.cpp	2018-02-28 18:43:28.802051935 -0500
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "../../../UBSI.h"
 #include "nsContentUtils.h"
 #include "nsIDocument.h"
 #include "mozilla/Sprintf.h"
@@ -217,6 +218,7 @@
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
+		UBSI_MEM_WRITE((void*)this);
   EventListenerManager* elm = GetOrCreateListenerManager();
   NS_ENSURE_STATE(elm);
   elm->AddEventListener(aType, aListener, aUseCapture, aWantsUntrusted);
@@ -275,6 +277,7 @@
 DOMEventTargetHelper::DispatchEvent(nsIDOMEvent* aEvent, bool* aRetVal)
 {
   nsEventStatus status = nsEventStatus_eIgnore;
+		UBSI_MEM_READ((void*)aEvent);
   nsresult rv =
     EventDispatcher::DispatchDOMEvent(this, nullptr, aEvent, nullptr, &status);
 
@@ -287,6 +290,7 @@
 {
   RefPtr<Event> event = NS_NewDOMEvent(this, nullptr, nullptr);
   event->InitEvent(aEventName, false, false);
+		UBSI_MEM_READ((void*)event);
 
   return DispatchTrustedEvent(event);
 }
--- firefox-54.0.1/dom/events/EventTarget.cpp	2017-06-15 16:52:17.000000000 -0400
+++ firefox-54.0.1_backup/dom/events/EventTarget.cpp	2018-02-28 18:53:49.310051935 -0500
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "../../../UBSI.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/dom/EventTarget.h"
 #include "mozilla/dom/EventTargetBinding.h"
@@ -70,6 +71,7 @@
                            ErrorResult& aRv)
 {
   bool result = false;
+		UBSI_MEM_READ((void*)&aEvent);
   aRv = DispatchEvent(&aEvent, &result);
   return !aEvent.DefaultPrevented(aCallerType);
 }
--- firefox-54.0.1/dom/events/EventListenerManager.cpp	2017-06-15 16:52:17.000000000 -0400
+++ firefox-54.0.1_backup/dom/events/EventListenerManager.cpp	2018-02-28 16:39:07.870051935 -0500
@@ -7,6 +7,7 @@
 // Microsoft's API Name hackery sucks
 #undef CreateEvent
 
+#include "../../../UBSI.h"
 #include "mozilla/AddonPathService.h"
 #include "mozilla/BasicEvents.h"
 #include "mozilla/CycleCollectedJSContext.h"
@@ -1388,6 +1389,7 @@
                         bool aUseCapture,
                         bool aWantsUntrusted)
 {
+		UBSI_MEM_WRITE((void*)this);
   EventListenerFlags flags;
   flags.mCapture = aUseCapture;
   flags.mAllowUntrustedEvents = aWantsUntrusted;
--- firefox-54.0.1/dom/events/TextComposition.cpp	2017-06-15 16:52:17.000000000 -0400
+++ firefox-54.0.1_backup/dom/events/TextComposition.cpp	2018-02-28 20:41:43.866051935 -0500
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "../../../UBSI.h"
 #include "ContentEventHandler.h"
 #include "IMEContentObserver.h"
 #include "IMEStateManager.h"
@@ -148,6 +149,7 @@
                                EventDispatchingCallback* aCallBack,
                                const WidgetCompositionEvent *aOriginalEvent)
 {
+		UBSI_MEM_READ((void*)aDispatchEvent);
   nsPluginInstanceOwner::GeneratePluginEvent(aOriginalEvent,
                                              aDispatchEvent);
 
--- firefox-54.0.1/dom/base/nsTextFragment.cpp	2017-06-15 16:52:09.000000000 -0400
+++ firefox-54.0.1_backup/dom/base/nsTextFragment.cpp	2018-02-24 17:14:23.038051935 -0500
@@ -10,6 +10,7 @@
  * a char*; otherwise the text is stored as a char16_t*
  */
 
+#include "../../../UBSI.h"
 #include "nsTextFragment.h"
 #include "nsCRT.h"
 #include "nsReadableUtils.h"
@@ -114,6 +115,8 @@
       }
 
       if (m2b) {
+								UBSI_MEM_READ((void*)aOther.m2b);
+								UBSI_MEM_WRITE((void*)m2b);
         memcpy(m2b, aOther.m2b, m2bSize.value());
       } else {
         // allocate a buffer for a single REPLACEMENT CHARACTER
@@ -312,6 +315,8 @@
   }
 
   if (aCount != 0) {
+				UBSI_MEM_READ((void*)m2b + aOffset);
+				UBSI_MEM_WRITE((void*)aDest);
     if (mState.mIs2b) {
       memcpy(aDest, m2b + aOffset, sizeof(char16_t) * aCount);
     } else {
--- firefox-54.0.1/dom/base/nsContentUtils.cpp	2017-06-15 16:52:09.000000000 -0400
+++ firefox-54.0.1_backup/dom/base/nsContentUtils.cpp	2018-02-28 20:39:19.450051935 -0500
@@ -6,6 +6,7 @@
 
 /* A namespace class for static layout utilities. */
 
+#include "../../../UBSI.h"
 #include "nsContentUtils.h"
 
 #include <algorithm>
@@ -4078,6 +4079,8 @@
                               bool aTrusted, bool *aDefaultAction,
                               bool aOnlyChromeDispatch)
 {
+		UBSI_MEM_READ((void*)aTarget);
+		UBSI_MEM_READ((void*)aDoc);
   nsCOMPtr<nsIDOMEvent> event;
   nsCOMPtr<EventTarget> target;
   nsresult rv = GetEventAndTarget(aDoc, aTarget, aEventName, aCanBubble,
--- firefox-54.0.1/dom/base/nsGlobalWindow.cpp	2017-06-15 16:52:09.000000000 -0400
+++ firefox-54.0.1_backup/dom/base/nsGlobalWindow.cpp	2018-02-28 16:36:57.874051935 -0500
@@ -5,6 +5,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsGlobalWindow.h"
+#include "../../../UBSI.h"
 
 #include <algorithm>
 
@@ -10114,6 +10115,7 @@
     aWantsUntrusted = true;
   }
 
+		UBSI_MEM_WRITE((void*)this);
   EventListenerManager* manager = GetOrCreateListenerManager();
   NS_ENSURE_STATE(manager);
   manager->AddEventListener(aType, aListener, aUseCapture, aWantsUntrusted);
--- firefox-54.0.1/dom/base/nsWindowRoot.cpp	2017-06-15 16:52:09.000000000 -0400
+++ firefox-54.0.1_backup/dom/base/nsWindowRoot.cpp	2018-02-28 16:38:02.090051935 -0500
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "../../../UBSI.h"
 #include "mozilla/BasicEvents.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/EventListenerManager.h"
@@ -116,6 +117,7 @@
                "aWantsUntrusted to false or make the aWantsUntrusted "
                "explicit by making optional_argc non-zero.");
 
+		UBSI_MEM_WRITE((void*)this);
   EventListenerManager* elm = GetOrCreateListenerManager();
   NS_ENSURE_STATE(elm);
   elm->AddEventListener(aType, aListener, aUseCapture, aWantsUntrusted);
--- firefox-54.0.1/dom/base/nsINode.cpp	2017-06-15 16:52:09.000000000 -0400
+++ firefox-54.0.1_backup/dom/base/nsINode.cpp	2018-02-28 16:13:53.142051935 -0500
@@ -8,6 +8,7 @@
  * Base class for all DOM nodes.
  */
 
+#include "../../../UBSI.h"
 #include "nsINode.h"
 
 #include "AccessCheck.h"
@@ -1188,7 +1189,8 @@
        !nsContentUtils::IsChromeDoc(OwnerDoc()))) {
     aWantsUntrusted = true;
   }
-
+		
+		UBSI_MEM_WRITE((void*)this);
   EventListenerManager* listener_manager = GetOrCreateListenerManager();
   NS_ENSURE_STATE(listener_manager);
   listener_manager->AddEventListener(aType, aListener, aUseCapture,
@@ -1210,6 +1212,7 @@
     wantsUntrusted = aWantsUntrusted.Value();
   }
 
+		UBSI_MEM_WRITE((void*)this);
   EventListenerManager* listener_manager = GetOrCreateListenerManager();
   if (!listener_manager) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
@@ -1318,7 +1321,8 @@
     *aRetVal = true;
     return NS_OK;
   }
-
+		
+		UBSI_MEM_READ((void*)aEvent);
   // Obtain a presentation shell
   nsIPresShell *shell = document->GetShell();
   RefPtr<nsPresContext> context;
--- firefox-54.0.1/dom/base/Element.cpp	2017-06-15 16:52:08.000000000 -0400
+++ firefox-54.0.1_backup/dom/base/Element.cpp	2018-02-28 18:41:11.146051935 -0500
@@ -10,6 +10,7 @@
  * utility methods for subclasses, and so forth.
  */
 
+#include "../../../UBSI.h"
 #include "mozilla/dom/ElementInlines.h"
 
 #include "AnimationCommon.h"
@@ -2101,6 +2102,8 @@
     return NS_OK;
   }
 
+		UBSI_MEM_READ((void*)aEvent);
+		UBSI_MEM_READ((void*)aTarget);
   if (aFullDispatch) {
     return shell->HandleEventWithTarget(aEvent, nullptr, aTarget, aStatus);
   }
--- firefox-54.0.1/netwerk/base/nsSocketTransportService2.cpp	2017-06-15 16:52:27.000000000 -0400
+++ firefox-54.0.1_backup/netwerk/base/nsSocketTransportService2.cpp	2018-02-23 20:05:17.594051935 -0500
@@ -3,6 +3,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "../../UBSI.h"
 #include "nsSocketTransportService2.h"
 #include "nsSocketTransport2.h"
 #include "NetworkActivityMonitor.h"
@@ -902,6 +903,7 @@
         pollDuration = 0;
 
         do {
+            UBSI_LOOP_ENTRY(1);
             if (mTelemetryEnabledPref) {
                 pollCycleStart = TimeStamp::NowLoRes();
             }
@@ -968,6 +970,7 @@
                 }
             }
         } while (pendingEvents);
+        UBSI_LOOP_EXIT(1);
 
         bool goingOffline = false;
         // now that our event queue is empty, check to see if we should exit
--- firefox-54.0.1/netwerk/base/nsSocketTransport2.cpp	2017-06-15 16:52:27.000000000 -0400
+++ firefox-54.0.1_backup/netwerk/base/nsSocketTransport2.cpp	2018-02-23 20:05:17.594051935 -0500
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "../../UBSI.h"
 #include "nsSocketTransport2.h"
 
 #include "mozilla/Attributes.h"
@@ -397,6 +398,7 @@
     // cannot hold lock while calling NSPR.  (worried about the fact that PSM
     // synchronously proxies notifications over to the UI thread, which could
     // mistakenly try to re-enter this code.)
+    UBSI_MEM_WRITE(buf);
     int32_t n = PR_Read(fd, buf, count);
 
     SOCKET_LOG(("  PR_Read returned [n=%d]\n", n));
